// This is a generated file. Not intended for manual editing.
package com.rawatech.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import com.rawatech.psi.impl.*;

public interface VHDLTypes {

  IElementType ABSTRACT_LITERAL = new VHDLElementType("ABSTRACT_LITERAL");
  IElementType ACCESS_TYPE_DEFINITION = new VHDLElementType("ACCESS_TYPE_DEFINITION");
  IElementType ACTUAL_DESIGNATOR = new VHDLElementType("ACTUAL_DESIGNATOR");
  IElementType ACTUAL_PARAMETER_PART = new VHDLElementType("ACTUAL_PARAMETER_PART");
  IElementType ACTUAL_PART = new VHDLElementType("ACTUAL_PART");
  IElementType ADDING_OPERATOR = new VHDLElementType("ADDING_OPERATOR");
  IElementType AGGREGATE = new VHDLElementType("AGGREGATE");
  IElementType ALIAS_DECLARATION = new VHDLElementType("ALIAS_DECLARATION");
  IElementType ALIAS_DESIGNATOR = new VHDLElementType("ALIAS_DESIGNATOR");
  IElementType ALLOCATOR = new VHDLElementType("ALLOCATOR");
  IElementType ARCHITECTURE_BODY = new VHDLElementType("ARCHITECTURE_BODY");
  IElementType ARCHITECTURE_DECLARATIVE_PART = new VHDLElementType("ARCHITECTURE_DECLARATIVE_PART");
  IElementType ARCHITECTURE_STATEMENT_PART = new VHDLElementType("ARCHITECTURE_STATEMENT_PART");
  IElementType ARRAY_TYPE_DEFINITION = new VHDLElementType("ARRAY_TYPE_DEFINITION");
  IElementType ASSERTION = new VHDLElementType("ASSERTION");
  IElementType ASSERTION_STATEMENT = new VHDLElementType("ASSERTION_STATEMENT");
  IElementType ASSOCIATION_ELEMENT = new VHDLElementType("ASSOCIATION_ELEMENT");
  IElementType ASSOCIATION_LIST = new VHDLElementType("ASSOCIATION_LIST");
  IElementType ATTRIBUTE_DECLARATION = new VHDLElementType("ATTRIBUTE_DECLARATION");
  IElementType ATTRIBUTE_DESIGNATOR = new VHDLElementType("ATTRIBUTE_DESIGNATOR");
  IElementType ATTRIBUTE_NAME = new VHDLElementType("ATTRIBUTE_NAME");
  IElementType ATTRIBUTE_SPECIFICATION = new VHDLElementType("ATTRIBUTE_SPECIFICATION");
  IElementType BASE = new VHDLElementType("BASE");
  IElementType BASED_INTEGER = new VHDLElementType("BASED_INTEGER");
  IElementType BASED_LITERAL = new VHDLElementType("BASED_LITERAL");
  IElementType BASE_SPECIFIER = new VHDLElementType("BASE_SPECIFIER");
  IElementType BASE_UNIT_DECLARATION = new VHDLElementType("BASE_UNIT_DECLARATION");
  IElementType BASIC_CHARACTER = new VHDLElementType("BASIC_CHARACTER");
  IElementType BASIC_GRAPHIC_CHARACTER = new VHDLElementType("BASIC_GRAPHIC_CHARACTER");
  IElementType BASIC_IDENTIFIER = new VHDLElementType("BASIC_IDENTIFIER");
  IElementType BINDING_INDICATION = new VHDLElementType("BINDING_INDICATION");
  IElementType BIT_STRING_LITERAL = new VHDLElementType("BIT_STRING_LITERAL");
  IElementType BIT_VALUE = new VHDLElementType("BIT_VALUE");
  IElementType BLOCK_CONFIGURATION = new VHDLElementType("BLOCK_CONFIGURATION");
  IElementType BLOCK_DECLARATIVE_ITEM = new VHDLElementType("BLOCK_DECLARATIVE_ITEM");
  IElementType BLOCK_DECLARATIVE_PART = new VHDLElementType("BLOCK_DECLARATIVE_PART");
  IElementType BLOCK_HEADER = new VHDLElementType("BLOCK_HEADER");
  IElementType BLOCK_SPECIFICATION = new VHDLElementType("BLOCK_SPECIFICATION");
  IElementType BLOCK_STATEMENT = new VHDLElementType("BLOCK_STATEMENT");
  IElementType BLOCK_STATEMENT_PART = new VHDLElementType("BLOCK_STATEMENT_PART");
  IElementType CASE_STATEMENT = new VHDLElementType("CASE_STATEMENT");
  IElementType CASE_STATEMENT_ALTERNATIVE = new VHDLElementType("CASE_STATEMENT_ALTERNATIVE");
  IElementType CHARACTER_LITERAL = new VHDLElementType("CHARACTER_LITERAL");
  IElementType CHOICE = new VHDLElementType("CHOICE");
  IElementType CHOICES = new VHDLElementType("CHOICES");
  IElementType COMPONENT_CONFIGURATION = new VHDLElementType("COMPONENT_CONFIGURATION");
  IElementType COMPONENT_DECLARATION = new VHDLElementType("COMPONENT_DECLARATION");
  IElementType COMPONENT_INSTANTIATION_STATEMENT = new VHDLElementType("COMPONENT_INSTANTIATION_STATEMENT");
  IElementType COMPONENT_SPECIFICATION = new VHDLElementType("COMPONENT_SPECIFICATION");
  IElementType COMPOSITE_TYPE_DEFINITION = new VHDLElementType("COMPOSITE_TYPE_DEFINITION");
  IElementType CONCURRENT_ASSERTION_STATEMENT = new VHDLElementType("CONCURRENT_ASSERTION_STATEMENT");
  IElementType CONCURRENT_PROCEDURE_CALL_STATEMENT = new VHDLElementType("CONCURRENT_PROCEDURE_CALL_STATEMENT");
  IElementType CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT = new VHDLElementType("CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT");
  IElementType CONCURRENT_STATEMENT = new VHDLElementType("CONCURRENT_STATEMENT");
  IElementType CONDITION = new VHDLElementType("CONDITION");
  IElementType CONDITIONAL_SIGNAL_ASSIGNMENT = new VHDLElementType("CONDITIONAL_SIGNAL_ASSIGNMENT");
  IElementType CONDITIONAL_WAVEFORMS = new VHDLElementType("CONDITIONAL_WAVEFORMS");
  IElementType CONDITION_CLAUSE = new VHDLElementType("CONDITION_CLAUSE");
  IElementType CONFIGURATION_DECLARATION = new VHDLElementType("CONFIGURATION_DECLARATION");
  IElementType CONFIGURATION_DECLARATIVE_ITEM = new VHDLElementType("CONFIGURATION_DECLARATIVE_ITEM");
  IElementType CONFIGURATION_DECLARATIVE_PART = new VHDLElementType("CONFIGURATION_DECLARATIVE_PART");
  IElementType CONFIGURATION_ITEM = new VHDLElementType("CONFIGURATION_ITEM");
  IElementType CONFIGURATION_SPECIFICATION = new VHDLElementType("CONFIGURATION_SPECIFICATION");
  IElementType CONSTANT_DECLARATION = new VHDLElementType("CONSTANT_DECLARATION");
  IElementType CONSTRAINED_ARRAY_DEFINITION = new VHDLElementType("CONSTRAINED_ARRAY_DEFINITION");
  IElementType CONSTRAINT = new VHDLElementType("CONSTRAINT");
  IElementType CONTEXT_CLAUSE = new VHDLElementType("CONTEXT_CLAUSE");
  IElementType CONTEXT_ITEM = new VHDLElementType("CONTEXT_ITEM");
  IElementType DECIMAL_LITERAL = new VHDLElementType("DECIMAL_LITERAL");
  IElementType DECLARATION = new VHDLElementType("DECLARATION");
  IElementType DELAY_MECHANISM = new VHDLElementType("DELAY_MECHANISM");
  IElementType DESIGNATOR = new VHDLElementType("DESIGNATOR");
  IElementType DESIGN_FILE = new VHDLElementType("DESIGN_FILE");
  IElementType DESIGN_UNIT = new VHDLElementType("DESIGN_UNIT");
  IElementType DIRECTION = new VHDLElementType("DIRECTION");
  IElementType DISCONNECTION_SPECIFICATION = new VHDLElementType("DISCONNECTION_SPECIFICATION");
  IElementType DISCRETE_RANGE = new VHDLElementType("DISCRETE_RANGE");
  IElementType ELEMENT_ASSOCIATION = new VHDLElementType("ELEMENT_ASSOCIATION");
  IElementType ELEMENT_DECLARATION = new VHDLElementType("ELEMENT_DECLARATION");
  IElementType ELEMENT_SUBTYPE_DEFINITION = new VHDLElementType("ELEMENT_SUBTYPE_DEFINITION");
  IElementType ENTITY_ASPECT = new VHDLElementType("ENTITY_ASPECT");
  IElementType ENTITY_CLASS = new VHDLElementType("ENTITY_CLASS");
  IElementType ENTITY_CLASS_ENTRY = new VHDLElementType("ENTITY_CLASS_ENTRY");
  IElementType ENTITY_CLASS_ENTRY_LIST = new VHDLElementType("ENTITY_CLASS_ENTRY_LIST");
  IElementType ENTITY_DECLARATION = new VHDLElementType("ENTITY_DECLARATION");
  IElementType ENTITY_DECLARATIVE_ITEM = new VHDLElementType("ENTITY_DECLARATIVE_ITEM");
  IElementType ENTITY_DECLARATIVE_PART = new VHDLElementType("ENTITY_DECLARATIVE_PART");
  IElementType ENTITY_DESIGNATOR = new VHDLElementType("ENTITY_DESIGNATOR");
  IElementType ENTITY_HEADER = new VHDLElementType("ENTITY_HEADER");
  IElementType ENTITY_NAME_LIST = new VHDLElementType("ENTITY_NAME_LIST");
  IElementType ENTITY_SPECIFICATION = new VHDLElementType("ENTITY_SPECIFICATION");
  IElementType ENTITY_STATEMENT = new VHDLElementType("ENTITY_STATEMENT");
  IElementType ENTITY_STATEMENT_PART = new VHDLElementType("ENTITY_STATEMENT_PART");
  IElementType ENTITY_TAG = new VHDLElementType("ENTITY_TAG");
  IElementType ENUMERATION_LITERAL = new VHDLElementType("ENUMERATION_LITERAL");
  IElementType ENUMERATION_TYPE_DEFINITION = new VHDLElementType("ENUMERATION_TYPE_DEFINITION");
  IElementType EXIT_STATEMENT = new VHDLElementType("EXIT_STATEMENT");
  IElementType EXPONENT = new VHDLElementType("EXPONENT");
  IElementType EXPRESSION = new VHDLElementType("EXPRESSION");
  IElementType EXTENDED_DIGIT = new VHDLElementType("EXTENDED_DIGIT");
  IElementType EXTENDED_IDENTIFIER = new VHDLElementType("EXTENDED_IDENTIFIER");
  IElementType FACTOR = new VHDLElementType("FACTOR");
  IElementType FILE_DECLARATION = new VHDLElementType("FILE_DECLARATION");
  IElementType FILE_LOGICAL_NAME = new VHDLElementType("FILE_LOGICAL_NAME");
  IElementType FILE_OPEN_INFORMATION = new VHDLElementType("FILE_OPEN_INFORMATION");
  IElementType FILE_TYPE_DEFINITION = new VHDLElementType("FILE_TYPE_DEFINITION");
  IElementType FLOATING_TYPE_DEFINITION = new VHDLElementType("FLOATING_TYPE_DEFINITION");
  IElementType FORMAL_DESIGNATOR = new VHDLElementType("FORMAL_DESIGNATOR");
  IElementType FORMAL_PARAMETER_LIST = new VHDLElementType("FORMAL_PARAMETER_LIST");
  IElementType FORMAL_PART = new VHDLElementType("FORMAL_PART");
  IElementType FULL_TYPE_DECLARATION = new VHDLElementType("FULL_TYPE_DECLARATION");
  IElementType FUNCTION_CALL = new VHDLElementType("FUNCTION_CALL");
  IElementType GENERATE_STATEMENT = new VHDLElementType("GENERATE_STATEMENT");
  IElementType GENERATION_SCHEME = new VHDLElementType("GENERATION_SCHEME");
  IElementType GENERIC_CLAUSE = new VHDLElementType("GENERIC_CLAUSE");
  IElementType GENERIC_LIST = new VHDLElementType("GENERIC_LIST");
  IElementType GENERIC_MAP_ASPECT = new VHDLElementType("GENERIC_MAP_ASPECT");
  IElementType GRAPHIC_CHARACTER = new VHDLElementType("GRAPHIC_CHARACTER");
  IElementType GROUP_CONSTITUENT = new VHDLElementType("GROUP_CONSTITUENT");
  IElementType GROUP_CONSTITUENT_LIST = new VHDLElementType("GROUP_CONSTITUENT_LIST");
  IElementType GROUP_DECLARATION = new VHDLElementType("GROUP_DECLARATION");
  IElementType GROUP_TEMPLATE_DECLARATION = new VHDLElementType("GROUP_TEMPLATE_DECLARATION");
  IElementType GUARDED_SIGNAL_SPECIFICATION = new VHDLElementType("GUARDED_SIGNAL_SPECIFICATION");
  IElementType IDENTIFIER = new VHDLElementType("IDENTIFIER");
  IElementType IDENTIFIER_LIST = new VHDLElementType("IDENTIFIER_LIST");
  IElementType IF_STATEMENT = new VHDLElementType("IF_STATEMENT");
  IElementType INCOMPLETE_TYPE_DECLARATION = new VHDLElementType("INCOMPLETE_TYPE_DECLARATION");
  IElementType INDEXED_NAME = new VHDLElementType("INDEXED_NAME");
  IElementType INDEX_CONSTRAINT = new VHDLElementType("INDEX_CONSTRAINT");
  IElementType INDEX_SPECIFICATION = new VHDLElementType("INDEX_SPECIFICATION");
  IElementType INDEX_SUBTYPE_DEFINITION = new VHDLElementType("INDEX_SUBTYPE_DEFINITION");
  IElementType INSTANTIATED_UNIT = new VHDLElementType("INSTANTIATED_UNIT");
  IElementType INSTANTIATION_LIST = new VHDLElementType("INSTANTIATION_LIST");
  IElementType INTEGER = new VHDLElementType("INTEGER");
  IElementType INTEGER_TYPE_DEFINITION = new VHDLElementType("INTEGER_TYPE_DEFINITION");
  IElementType INTERFACE_CONSTANT_DECLARATION = new VHDLElementType("INTERFACE_CONSTANT_DECLARATION");
  IElementType INTERFACE_DECLARATION = new VHDLElementType("INTERFACE_DECLARATION");
  IElementType INTERFACE_ELEMENT = new VHDLElementType("INTERFACE_ELEMENT");
  IElementType INTERFACE_FILE_DECLARATION = new VHDLElementType("INTERFACE_FILE_DECLARATION");
  IElementType INTERFACE_LIST = new VHDLElementType("INTERFACE_LIST");
  IElementType INTERFACE_SIGNAL_DECLARATION = new VHDLElementType("INTERFACE_SIGNAL_DECLARATION");
  IElementType INTERFACE_VARIABLE_DECLARATION = new VHDLElementType("INTERFACE_VARIABLE_DECLARATION");
  IElementType ITERATION_SCHEME = new VHDLElementType("ITERATION_SCHEME");
  IElementType LABEL = new VHDLElementType("LABEL");
  IElementType LETTER = new VHDLElementType("LETTER");
  IElementType LETTER_OR_DIGIT = new VHDLElementType("LETTER_OR_DIGIT");
  IElementType LIBRARY_CLAUSE = new VHDLElementType("LIBRARY_CLAUSE");
  IElementType LIBRARY_UNIT = new VHDLElementType("LIBRARY_UNIT");
  IElementType LITERAL = new VHDLElementType("LITERAL");
  IElementType LOGICAL_NAME = new VHDLElementType("LOGICAL_NAME");
  IElementType LOGICAL_NAME_LIST = new VHDLElementType("LOGICAL_NAME_LIST");
  IElementType LOGICAL_OPERATOR = new VHDLElementType("LOGICAL_OPERATOR");
  IElementType LOOP_STATEMENT = new VHDLElementType("LOOP_STATEMENT");
  IElementType MISCELLANEOUS_OPERATOR = new VHDLElementType("MISCELLANEOUS_OPERATOR");
  IElementType MODE = new VHDLElementType("MODE");
  IElementType MULTIPLYING_OPERATOR = new VHDLElementType("MULTIPLYING_OPERATOR");
  IElementType NAME = new VHDLElementType("NAME");
  IElementType NEXT_STATEMENT = new VHDLElementType("NEXT_STATEMENT");
  IElementType NULL_STATEMENT = new VHDLElementType("NULL_STATEMENT");
  IElementType NUMERIC_LITERAL = new VHDLElementType("NUMERIC_LITERAL");
  IElementType OBJECT_DECLARATION = new VHDLElementType("OBJECT_DECLARATION");
  IElementType OPERATOR_SYMBOL = new VHDLElementType("OPERATOR_SYMBOL");
  IElementType OPTIONS = new VHDLElementType("OPTIONS");
  IElementType PACKAGE_BODY = new VHDLElementType("PACKAGE_BODY");
  IElementType PACKAGE_BODY_DECLARATIVE_ITEM = new VHDLElementType("PACKAGE_BODY_DECLARATIVE_ITEM");
  IElementType PACKAGE_BODY_DECLARATIVE_PART = new VHDLElementType("PACKAGE_BODY_DECLARATIVE_PART");
  IElementType PACKAGE_DECLARATION = new VHDLElementType("PACKAGE_DECLARATION");
  IElementType PACKAGE_DECLARATIVE_ITEM = new VHDLElementType("PACKAGE_DECLARATIVE_ITEM");
  IElementType PACKAGE_DECLARATIVE_PART = new VHDLElementType("PACKAGE_DECLARATIVE_PART");
  IElementType PARAMETER_SPECIFICATION = new VHDLElementType("PARAMETER_SPECIFICATION");
  IElementType PHYSICAL_LITERAL = new VHDLElementType("PHYSICAL_LITERAL");
  IElementType PHYSICAL_TYPE_DEFINITION = new VHDLElementType("PHYSICAL_TYPE_DEFINITION");
  IElementType PORT_CLAUSE = new VHDLElementType("PORT_CLAUSE");
  IElementType PORT_LIST = new VHDLElementType("PORT_LIST");
  IElementType PORT_MAP_ASPECT = new VHDLElementType("PORT_MAP_ASPECT");
  IElementType PREFIX = new VHDLElementType("PREFIX");
  IElementType PRIMARY = new VHDLElementType("PRIMARY");
  IElementType PRIMARY_UNIT = new VHDLElementType("PRIMARY_UNIT");
  IElementType PROCEDURE_CALL = new VHDLElementType("PROCEDURE_CALL");
  IElementType PROCEDURE_CALL_STATEMENT = new VHDLElementType("PROCEDURE_CALL_STATEMENT");
  IElementType PROCESS_DECLARATIVE_ITEM = new VHDLElementType("PROCESS_DECLARATIVE_ITEM");
  IElementType PROCESS_DECLARATIVE_PART = new VHDLElementType("PROCESS_DECLARATIVE_PART");
  IElementType PROCESS_STATEMENT = new VHDLElementType("PROCESS_STATEMENT");
  IElementType PROCESS_STATEMENT_PART = new VHDLElementType("PROCESS_STATEMENT_PART");
  IElementType QUALIFIED_EXPRESSION = new VHDLElementType("QUALIFIED_EXPRESSION");
  IElementType RANGE = new VHDLElementType("RANGE");
  IElementType RANGE_CONSTRAINT = new VHDLElementType("RANGE_CONSTRAINT");
  IElementType RECORD_TYPE_DEFINITION = new VHDLElementType("RECORD_TYPE_DEFINITION");
  IElementType RELATION = new VHDLElementType("RELATION");
  IElementType RELATIONAL_OPERATOR = new VHDLElementType("RELATIONAL_OPERATOR");
  IElementType REPORT_STATEMENT = new VHDLElementType("REPORT_STATEMENT");
  IElementType RETURN_STATEMENT = new VHDLElementType("RETURN_STATEMENT");
  IElementType SCALAR_TYPE_DEFINITION = new VHDLElementType("SCALAR_TYPE_DEFINITION");
  IElementType SECONDARY_UNIT = new VHDLElementType("SECONDARY_UNIT");
  IElementType SECONDARY_UNIT_DECLARATION = new VHDLElementType("SECONDARY_UNIT_DECLARATION");
  IElementType SELECTED_NAME = new VHDLElementType("SELECTED_NAME");
  IElementType SELECTED_SIGNAL_ASSIGNMENT = new VHDLElementType("SELECTED_SIGNAL_ASSIGNMENT");
  IElementType SELECTED_WAVEFORMS = new VHDLElementType("SELECTED_WAVEFORMS");
  IElementType SENSITIVITY_CLAUSE = new VHDLElementType("SENSITIVITY_CLAUSE");
  IElementType SENSITIVITY_LIST = new VHDLElementType("SENSITIVITY_LIST");
  IElementType SEQUENCE_OF_STATEMENTS = new VHDLElementType("SEQUENCE_OF_STATEMENTS");
  IElementType SEQUENTIAL_STATEMENT = new VHDLElementType("SEQUENTIAL_STATEMENT");
  IElementType SHIFT_EXPRESSION = new VHDLElementType("SHIFT_EXPRESSION");
  IElementType SHIFT_OPERATOR = new VHDLElementType("SHIFT_OPERATOR");
  IElementType SIGN = new VHDLElementType("SIGN");
  IElementType SIGNAL_ASSIGNMENT_STATEMENT = new VHDLElementType("SIGNAL_ASSIGNMENT_STATEMENT");
  IElementType SIGNAL_DECLARATION = new VHDLElementType("SIGNAL_DECLARATION");
  IElementType SIGNAL_KIND = new VHDLElementType("SIGNAL_KIND");
  IElementType SIGNAL_LIST = new VHDLElementType("SIGNAL_LIST");
  IElementType SIGNATURE = new VHDLElementType("SIGNATURE");
  IElementType SIMPLE_EXPRESSION = new VHDLElementType("SIMPLE_EXPRESSION");
  IElementType SIMPLE_NAME = new VHDLElementType("SIMPLE_NAME");
  IElementType SLICE_NAME = new VHDLElementType("SLICE_NAME");
  IElementType STRING_LITERAL = new VHDLElementType("STRING_LITERAL");
  IElementType SUBPROGRAM_BODY = new VHDLElementType("SUBPROGRAM_BODY");
  IElementType SUBPROGRAM_DECLARATION = new VHDLElementType("SUBPROGRAM_DECLARATION");
  IElementType SUBPROGRAM_DECLARATIVE_ITEM = new VHDLElementType("SUBPROGRAM_DECLARATIVE_ITEM");
  IElementType SUBPROGRAM_DECLARATIVE_PART = new VHDLElementType("SUBPROGRAM_DECLARATIVE_PART");
  IElementType SUBPROGRAM_KIND = new VHDLElementType("SUBPROGRAM_KIND");
  IElementType SUBPROGRAM_SPECIFICATION = new VHDLElementType("SUBPROGRAM_SPECIFICATION");
  IElementType SUBPROGRAM_STATEMENT_PART = new VHDLElementType("SUBPROGRAM_STATEMENT_PART");
  IElementType SUBTYPE_DECLARATION = new VHDLElementType("SUBTYPE_DECLARATION");
  IElementType SUBTYPE_INDICATION = new VHDLElementType("SUBTYPE_INDICATION");
  IElementType SUFFIX = new VHDLElementType("SUFFIX");
  IElementType TARGET = new VHDLElementType("TARGET");
  IElementType TERM = new VHDLElementType("TERM");
  IElementType TIMEOUT_CLAUSE = new VHDLElementType("TIMEOUT_CLAUSE");
  IElementType TYPE_CONVERSION = new VHDLElementType("TYPE_CONVERSION");
  IElementType TYPE_DECLARATION = new VHDLElementType("TYPE_DECLARATION");
  IElementType TYPE_DEFINITION = new VHDLElementType("TYPE_DEFINITION");
  IElementType TYPE_MARK = new VHDLElementType("TYPE_MARK");
  IElementType UNCONSTRAINED_ARRAY_DEFINITION = new VHDLElementType("UNCONSTRAINED_ARRAY_DEFINITION");
  IElementType USE_CLAUSE = new VHDLElementType("USE_CLAUSE");
  IElementType VARIABLE_ASSIGNMENT_STATEMENT = new VHDLElementType("VARIABLE_ASSIGNMENT_STATEMENT");
  IElementType VARIABLE_DECLARATION = new VHDLElementType("VARIABLE_DECLARATION");
  IElementType WAIT_STATEMENT = new VHDLElementType("WAIT_STATEMENT");
  IElementType WAVEFORM = new VHDLElementType("WAVEFORM");
  IElementType WAVEFORM_ELEMENT = new VHDLElementType("WAVEFORM_ELEMENT");

  IElementType ABS = new VHDLTokenType("ABS");
  IElementType ACCESS = new VHDLTokenType("ACCESS");
  IElementType AFTER = new VHDLTokenType("AFTER");
  IElementType ALIAS = new VHDLTokenType("ALIAS");
  IElementType ALL = new VHDLTokenType("ALL");
  IElementType AMPERSAND = new VHDLTokenType("&");
  IElementType AND = new VHDLTokenType("AND");
  IElementType ARCHITECTURE = new VHDLTokenType("ARCHITECTURE");
  IElementType ARCHITECTURE_IDENTIFIER = new VHDLTokenType("architecture_identifier");
  IElementType ARCHITECTURE_NAME = new VHDLTokenType("architecture_name");
  IElementType ARCHITECTURE_SIMPLE_NAME = new VHDLTokenType("architecture_simple_name");
  IElementType ARRAY = new VHDLTokenType("ARRAY");
  IElementType ASSERT = new VHDLTokenType("ASSERT");
  IElementType ATTRIBUTE = new VHDLTokenType("ATTRIBUTE");
  IElementType ATTRIBUTE_SIMPLE_NAME = new VHDLTokenType("attribute_simple_name");
  IElementType B = new VHDLTokenType("B");
  IElementType BACKSLASH = new VHDLTokenType("\\");
  IElementType BEGIN = new VHDLTokenType("BEGIN");
  IElementType BLOCK = new VHDLTokenType("BLOCK");
  IElementType BLOCK_LABEL = new VHDLTokenType("block_label");
  IElementType BLOCK_STATEMENT_LABEL = new VHDLTokenType("block_statement_label");
  IElementType BODY = new VHDLTokenType("BODY");
  IElementType BOOLEAN_EXPRESSION = new VHDLTokenType("boolean_expression");
  IElementType BUFFER = new VHDLTokenType("BUFFER");
  IElementType BUS = new VHDLTokenType("BUS");
  IElementType CASE = new VHDLTokenType("CASE");
  IElementType CASE_LABEL = new VHDLTokenType("case_label");
  IElementType CHOICES_1_0_0 = new VHDLTokenType("choices_1_0_0");
  IElementType COLON = new VHDLTokenType(":");
  IElementType COLONEQUALS = new VHDLTokenType(":=");
  IElementType COMMA = new VHDLTokenType("COMMA");
  IElementType COMMENT = new VHDLTokenType("COMMENT");
  IElementType COMPONENT = new VHDLTokenType("COMPONENT");
  IElementType COMPONENT_NAME = new VHDLTokenType("component_name");
  IElementType COMPONENT_SIMPLE_NAME = new VHDLTokenType("component_simple_name");
  IElementType CONFIGURATION = new VHDLTokenType("CONFIGURATION");
  IElementType CONFIGURATION_NAME = new VHDLTokenType("configuration_name");
  IElementType CONFIGURATION_SIMPLE_NAME = new VHDLTokenType("configuration_simple_name");
  IElementType CONSTANT = new VHDLTokenType("CONSTANT");
  IElementType DIGIT = new VHDLTokenType("digit");
  IElementType DIGIT_RE = new VHDLTokenType("DIGIT_RE");
  IElementType DISCONNECT = new VHDLTokenType("DISCONNECT");
  IElementType DISCRETE_SUBTYPE_INDICATION = new VHDLTokenType("discrete_subtype_indication");
  IElementType DOT = new VHDLTokenType("DOT");
  IElementType DOWNTO = new VHDLTokenType("DOWNTO");
  IElementType DQUOTE = new VHDLTokenType("\"");
  IElementType E = new VHDLTokenType("E");
  IElementType ELEMENT_SIMPLE_NAME = new VHDLTokenType("element_simple_name");
  IElementType ELEMENT_SUBTYPE_INDICATION = new VHDLTokenType("element_subtype_indication");
  IElementType ELSE = new VHDLTokenType("ELSE");
  IElementType ELSIF = new VHDLTokenType("ELSIF");
  IElementType END = new VHDLTokenType("END");
  IElementType ENTITY = new VHDLTokenType("ENTITY");
  IElementType ENTITY_NAME = new VHDLTokenType("entity_name");
  IElementType ENTITY_SIMPLE_NAME = new VHDLTokenType("entity_simple_name");
  IElementType EQUALS = new VHDLTokenType("=");
  IElementType EXIT = new VHDLTokenType("EXIT");
  IElementType FILE = new VHDLTokenType("FILE");
  IElementType FILE_NAME = new VHDLTokenType("file_name");
  IElementType FILE_OPEN_KIND_EXPRESSION = new VHDLTokenType("file_open_kind_expression");
  IElementType FOR = new VHDLTokenType("FOR");
  IElementType FORMAL_GENERIC_CLAUSE = new VHDLTokenType("formal_generic_clause");
  IElementType FORMAL_PORT_CLAUSE = new VHDLTokenType("formal_port_clause");
  IElementType FORMAT_EFFECTOR = new VHDLTokenType("format_effector");
  IElementType FUNCTION = new VHDLTokenType("FUNCTION");
  IElementType FUNCTION_NAME = new VHDLTokenType("function_name");
  IElementType GENERATE = new VHDLTokenType("GENERATE");
  IElementType GENERATE_LABEL = new VHDLTokenType("generate_label");
  IElementType GENERATE_PARAMETER_SPECIFICATION = new VHDLTokenType("generate_parameter_specification");
  IElementType GENERATE_STATEMENT_LABEL = new VHDLTokenType("generate_statement_label");
  IElementType GENERIC = new VHDLTokenType("GENERIC");
  IElementType GENERIC_ASSOCIATION_LIST = new VHDLTokenType("generic_association_list");
  IElementType GENERIC_INTERFACE_LIST = new VHDLTokenType("generic_interface_list");
  IElementType GENERIC_NAME = new VHDLTokenType("generic_name");
  IElementType GROUP = new VHDLTokenType("GROUP");
  IElementType GROUP_TEMPLATE_NAME = new VHDLTokenType("group_template_name");
  IElementType GUARDED = new VHDLTokenType("GUARDED");
  IElementType GUARDED_SIGNAL_LIST = new VHDLTokenType("guarded_signal_list");
  IElementType GUARD_EXPRESSION = new VHDLTokenType("guard_expression");
  IElementType HASH = new VHDLTokenType("#");
  IElementType IF = new VHDLTokenType("IF");
  IElementType IF_LABEL = new VHDLTokenType("if_label");
  IElementType IMPURE = new VHDLTokenType("IMPURE");
  IElementType IN = new VHDLTokenType("IN");
  IElementType INERTIAL = new VHDLTokenType("INERTIAL");
  IElementType INOUT = new VHDLTokenType("INOUT");
  IElementType INSTANTIATION_LABEL = new VHDLTokenType("instantiation_label");
  IElementType IS = new VHDLTokenType("IS");
  IElementType LABEL = new VHDLTokenType("LABEL");
  IElementType LARROW = new VHDLTokenType("<=");
  IElementType LIBRARY = new VHDLTokenType("LIBRARY");
  IElementType LINKAGE = new VHDLTokenType("LINKAGE");
  IElementType LITERAL = new VHDLTokenType("LITERAL");
  IElementType LOCAL_GENERIC_CLAUSE = new VHDLTokenType("local_generic_clause");
  IElementType LOCAL_PORT_CLAUSE = new VHDLTokenType("local_port_clause");
  IElementType LOOP = new VHDLTokenType("LOOP");
  IElementType LOOP_LABEL = new VHDLTokenType("loop_label");
  IElementType LOOP_PARAMETER_SPECIFICATION = new VHDLTokenType("loop_parameter_specification");
  IElementType LOWERCASE_RE = new VHDLTokenType("LOWERCASE_RE");
  IElementType LOWER_CASE_LETTER = new VHDLTokenType("lower_case_letter");
  IElementType MAP = new VHDLTokenType("MAP");
  IElementType MINUS = new VHDLTokenType("-");
  IElementType MULTIPLYING_OPERATOR_RE = new VHDLTokenType("MULTIPLYING_OPERATOR_RE");
  IElementType NAND = new VHDLTokenType("NAND");
  IElementType NEW = new VHDLTokenType("NEW");
  IElementType NEXT = new VHDLTokenType("NEXT");
  IElementType NOR = new VHDLTokenType("NOR");
  IElementType NOT = new VHDLTokenType("NOT");
  IElementType NULL = new VHDLTokenType("NULL");
  IElementType O = new VHDLTokenType("O");
  IElementType OF = new VHDLTokenType("OF");
  IElementType ON = new VHDLTokenType("ON");
  IElementType OPEN = new VHDLTokenType("OPEN");
  IElementType OR = new VHDLTokenType("OR");
  IElementType OTHERS = new VHDLTokenType("OTHERS");
  IElementType OTHER_SPECIAL_CHARACTER = new VHDLTokenType("other_special_character");
  IElementType OUT = new VHDLTokenType("OUT");
  IElementType PACKAGE = new VHDLTokenType("PACKAGE");
  IElementType PACKAGE_SIMPLE_NAME = new VHDLTokenType("package_simple_name");
  IElementType PARAMETER_ASSOCIATION_LIST = new VHDLTokenType("parameter_association_list");
  IElementType PARAMETER_INTERFACE_LIST = new VHDLTokenType("parameter_interface_list");
  IElementType PARAMETER_NAME = new VHDLTokenType("parameter_name");
  IElementType PARLEFT = new VHDLTokenType("(");
  IElementType PARRIGHT = new VHDLTokenType(")");
  IElementType PASSIVE_CONCURRENT_PROCEDURE_CALL_STATEMENT = new VHDLTokenType("passive_concurrent_procedure_call_statement");
  IElementType PASSIVE_PROCESS_STATEMENT = new VHDLTokenType("passive_process_statement");
  IElementType PHYSICAL_TYPE_SIMPLE_NAME = new VHDLTokenType("physical_type_simple_name");
  IElementType PIPE = new VHDLTokenType("|");
  IElementType PLUS = new VHDLTokenType("+");
  IElementType PORT = new VHDLTokenType("PORT");
  IElementType PORT_ASSOCIATION_LIST = new VHDLTokenType("port_association_list");
  IElementType PORT_INTERFACE_LIST = new VHDLTokenType("port_interface_list");
  IElementType PORT_NAME = new VHDLTokenType("port_name");
  IElementType POSTPONED = new VHDLTokenType("POSTPONED");
  IElementType PROCEDURE = new VHDLTokenType("PROCEDURE");
  IElementType PROCEDURE_NAME = new VHDLTokenType("procedure_name");
  IElementType PROCESS = new VHDLTokenType("PROCESS");
  IElementType PROCESS_LABEL = new VHDLTokenType("process_label");
  IElementType PURE = new VHDLTokenType("PURE");
  IElementType QUOTE = new VHDLTokenType("'");
  IElementType RANGE_ATTRIBUTE_NAME = new VHDLTokenType("range_attribute_name");
  IElementType RANGE_RE = new VHDLTokenType("<>");
  IElementType RARROW = new VHDLTokenType("RARROW");
  IElementType RECORD = new VHDLTokenType("RECORD");
  IElementType RECORD_TYPE_SIMPLE_NAME = new VHDLTokenType("record_type_simple_name");
  IElementType REGISTER = new VHDLTokenType("REGISTER");
  IElementType REJECT = new VHDLTokenType("REJECT");
  IElementType RELATIONAL_OPERATOR_RE = new VHDLTokenType("RELATIONAL_OPERATOR_RE");
  IElementType REPORT = new VHDLTokenType("REPORT");
  IElementType RESOLUTION_FUNCTION_NAME = new VHDLTokenType("resolution_function_name");
  IElementType RETURN = new VHDLTokenType("return");
  IElementType ROL = new VHDLTokenType("ROL");
  IElementType ROR = new VHDLTokenType("ROR");
  IElementType SELECT = new VHDLTokenType("SELECT");
  IElementType SEMICOLON = new VHDLTokenType("SEMICOLON");
  IElementType SEVERITY = new VHDLTokenType("SEVERITY");
  IElementType SHARED = new VHDLTokenType("SHARED");
  IElementType SHARED_VARIABLE_DECLARATION = new VHDLTokenType("shared_variable_declaration");
  IElementType SIGNAL = new VHDLTokenType("signal");
  IElementType SIGNAL_NAME = new VHDLTokenType("signal_name");
  IElementType SIGN_RE = new VHDLTokenType("SIGN_RE");
  IElementType SLA = new VHDLTokenType("SLA");
  IElementType SLL = new VHDLTokenType("SLL");
  IElementType SPACE = new VHDLTokenType(" ");
  IElementType SPACE_CHARACTER = new VHDLTokenType("space_character");
  IElementType SPECIAL_CHARACTER = new VHDLTokenType("special_character");
  IElementType SPECIAL_RE = new VHDLTokenType("SPECIAL_RE");
  IElementType SRA = new VHDLTokenType("SRA");
  IElementType SRL = new VHDLTokenType("SRL");
  IElementType STARSTAR = new VHDLTokenType("**");
  IElementType STATIC_EXPRESSION = new VHDLTokenType("static_expression");
  IElementType STRING_EXPRESSION = new VHDLTokenType("string_expression");
  IElementType SUBTYPE = new VHDLTokenType("SUBTYPE");
  IElementType SUBTYPE_NAME = new VHDLTokenType("subtype_name");
  IElementType THEN = new VHDLTokenType("THEN");
  IElementType TIME_EXPRESSION = new VHDLTokenType("time_expression");
  IElementType TO = new VHDLTokenType("TO");
  IElementType TRANSPORT = new VHDLTokenType("TRANSPORT");
  IElementType TYPE = new VHDLTokenType("TYPE");
  IElementType TYPE_NAME = new VHDLTokenType("type_name");
  IElementType UNAFFECTED = new VHDLTokenType("UNAFFECTED");
  IElementType UNDERLINE = new VHDLTokenType("underline");
  IElementType UNITS = new VHDLTokenType("UNITS");
  IElementType UNIT_NAME = new VHDLTokenType("unit_name");
  IElementType UNTIL = new VHDLTokenType("UNTIL");
  IElementType UPPERCASE_RE = new VHDLTokenType("UPPERCASE_RE");
  IElementType UPPER_CASE_LETTER = new VHDLTokenType("upper_case_letter");
  IElementType USE = new VHDLTokenType("USE");
  IElementType VALUE_EXPRESSION = new VHDLTokenType("value_expression");
  IElementType VARIABLE = new VHDLTokenType("VARIABLE");
  IElementType VARIABLE_NAME = new VHDLTokenType("variable_name");
  IElementType WAIT = new VHDLTokenType("WAIT");
  IElementType WHEN = new VHDLTokenType("WHEN");
  IElementType WHILE = new VHDLTokenType("WHILE");
  IElementType WITH = new VHDLTokenType("WITH");
  IElementType X = new VHDLTokenType("X");
  IElementType XNOR = new VHDLTokenType("XNOR");
  IElementType XOR = new VHDLTokenType("XOR");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
      if (type == ABSTRACT_LITERAL) {
        return new VHDLAbstractLiteralImpl(node);
      }
      else if (type == ACCESS_TYPE_DEFINITION) {
        return new VHDLAccessTypeDefinitionImpl(node);
      }
      else if (type == ACTUAL_DESIGNATOR) {
        return new VHDLActualDesignatorImpl(node);
      }
      else if (type == ACTUAL_PARAMETER_PART) {
        return new VHDLActualParameterPartImpl(node);
      }
      else if (type == ACTUAL_PART) {
        return new VHDLActualPartImpl(node);
      }
      else if (type == ADDING_OPERATOR) {
        return new VHDLAddingOperatorImpl(node);
      }
      else if (type == AGGREGATE) {
        return new VHDLAggregateImpl(node);
      }
      else if (type == ALIAS_DECLARATION) {
        return new VHDLAliasDeclarationImpl(node);
      }
      else if (type == ALIAS_DESIGNATOR) {
        return new VHDLAliasDesignatorImpl(node);
      }
      else if (type == ALLOCATOR) {
        return new VHDLAllocatorImpl(node);
      }
      else if (type == ARCHITECTURE_BODY) {
        return new VHDLArchitectureBodyImpl(node);
      }
      else if (type == ARCHITECTURE_DECLARATIVE_PART) {
        return new VHDLArchitectureDeclarativePartImpl(node);
      }
      else if (type == ARCHITECTURE_STATEMENT_PART) {
        return new VHDLArchitectureStatementPartImpl(node);
      }
      else if (type == ARRAY_TYPE_DEFINITION) {
        return new VHDLArrayTypeDefinitionImpl(node);
      }
      else if (type == ASSERTION) {
        return new VHDLAssertionImpl(node);
      }
      else if (type == ASSERTION_STATEMENT) {
        return new VHDLAssertionStatementImpl(node);
      }
      else if (type == ASSOCIATION_ELEMENT) {
        return new VHDLAssociationElementImpl(node);
      }
      else if (type == ASSOCIATION_LIST) {
        return new VHDLAssociationListImpl(node);
      }
      else if (type == ATTRIBUTE_DECLARATION) {
        return new VHDLAttributeDeclarationImpl(node);
      }
      else if (type == ATTRIBUTE_DESIGNATOR) {
        return new VHDLAttributeDesignatorImpl(node);
      }
      else if (type == ATTRIBUTE_NAME) {
        return new VHDLAttributeNameImpl(node);
      }
      else if (type == ATTRIBUTE_SPECIFICATION) {
        return new VHDLAttributeSpecificationImpl(node);
      }
      else if (type == BASE) {
        return new VHDLBaseImpl(node);
      }
      else if (type == BASED_INTEGER) {
        return new VHDLBasedIntegerImpl(node);
      }
      else if (type == BASED_LITERAL) {
        return new VHDLBasedLiteralImpl(node);
      }
      else if (type == BASE_SPECIFIER) {
        return new VHDLBaseSpecifierImpl(node);
      }
      else if (type == BASE_UNIT_DECLARATION) {
        return new VHDLBaseUnitDeclarationImpl(node);
      }
      else if (type == BASIC_CHARACTER) {
        return new VHDLBasicCharacterImpl(node);
      }
      else if (type == BASIC_GRAPHIC_CHARACTER) {
        return new VHDLBasicGraphicCharacterImpl(node);
      }
      else if (type == BASIC_IDENTIFIER) {
        return new VHDLBasicIdentifierImpl(node);
      }
      else if (type == BINDING_INDICATION) {
        return new VHDLBindingIndicationImpl(node);
      }
      else if (type == BIT_STRING_LITERAL) {
        return new VHDLBitStringLiteralImpl(node);
      }
      else if (type == BIT_VALUE) {
        return new VHDLBitValueImpl(node);
      }
      else if (type == BLOCK_CONFIGURATION) {
        return new VHDLBlockConfigurationImpl(node);
      }
      else if (type == BLOCK_DECLARATIVE_ITEM) {
        return new VHDLBlockDeclarativeItemImpl(node);
      }
      else if (type == BLOCK_DECLARATIVE_PART) {
        return new VHDLBlockDeclarativePartImpl(node);
      }
      else if (type == BLOCK_HEADER) {
        return new VHDLBlockHeaderImpl(node);
      }
      else if (type == BLOCK_SPECIFICATION) {
        return new VHDLBlockSpecificationImpl(node);
      }
      else if (type == BLOCK_STATEMENT) {
        return new VHDLBlockStatementImpl(node);
      }
      else if (type == BLOCK_STATEMENT_PART) {
        return new VHDLBlockStatementPartImpl(node);
      }
      else if (type == CASE_STATEMENT) {
        return new VHDLCaseStatementImpl(node);
      }
      else if (type == CASE_STATEMENT_ALTERNATIVE) {
        return new VHDLCaseStatementAlternativeImpl(node);
      }
      else if (type == CHARACTER_LITERAL) {
        return new VHDLCharacterLiteralImpl(node);
      }
      else if (type == CHOICE) {
        return new VHDLChoiceImpl(node);
      }
      else if (type == CHOICES) {
        return new VHDLChoicesImpl(node);
      }
      else if (type == COMPONENT_CONFIGURATION) {
        return new VHDLComponentConfigurationImpl(node);
      }
      else if (type == COMPONENT_DECLARATION) {
        return new VHDLComponentDeclarationImpl(node);
      }
      else if (type == COMPONENT_INSTANTIATION_STATEMENT) {
        return new VHDLComponentInstantiationStatementImpl(node);
      }
      else if (type == COMPONENT_SPECIFICATION) {
        return new VHDLComponentSpecificationImpl(node);
      }
      else if (type == COMPOSITE_TYPE_DEFINITION) {
        return new VHDLCompositeTypeDefinitionImpl(node);
      }
      else if (type == CONCURRENT_ASSERTION_STATEMENT) {
        return new VHDLConcurrentAssertionStatementImpl(node);
      }
      else if (type == CONCURRENT_PROCEDURE_CALL_STATEMENT) {
        return new VHDLConcurrentProcedureCallStatementImpl(node);
      }
      else if (type == CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT) {
        return new VHDLConcurrentSignalAssignmentStatementImpl(node);
      }
      else if (type == CONCURRENT_STATEMENT) {
        return new VHDLConcurrentStatementImpl(node);
      }
      else if (type == CONDITION) {
        return new VHDLConditionImpl(node);
      }
      else if (type == CONDITIONAL_SIGNAL_ASSIGNMENT) {
        return new VHDLConditionalSignalAssignmentImpl(node);
      }
      else if (type == CONDITIONAL_WAVEFORMS) {
        return new VHDLConditionalWaveformsImpl(node);
      }
      else if (type == CONDITION_CLAUSE) {
        return new VHDLConditionClauseImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATION) {
        return new VHDLConfigurationDeclarationImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATIVE_ITEM) {
        return new VHDLConfigurationDeclarativeItemImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATIVE_PART) {
        return new VHDLConfigurationDeclarativePartImpl(node);
      }
      else if (type == CONFIGURATION_ITEM) {
        return new VHDLConfigurationItemImpl(node);
      }
      else if (type == CONFIGURATION_SPECIFICATION) {
        return new VHDLConfigurationSpecificationImpl(node);
      }
      else if (type == CONSTANT_DECLARATION) {
        return new VHDLConstantDeclarationImpl(node);
      }
      else if (type == CONSTRAINED_ARRAY_DEFINITION) {
        return new VHDLConstrainedArrayDefinitionImpl(node);
      }
      else if (type == CONSTRAINT) {
        return new VHDLConstraintImpl(node);
      }
      else if (type == CONTEXT_CLAUSE) {
        return new VHDLContextClauseImpl(node);
      }
      else if (type == CONTEXT_ITEM) {
        return new VHDLContextItemImpl(node);
      }
      else if (type == DECIMAL_LITERAL) {
        return new VHDLDecimalLiteralImpl(node);
      }
      else if (type == DECLARATION) {
        return new VHDLDeclarationImpl(node);
      }
      else if (type == DELAY_MECHANISM) {
        return new VHDLDelayMechanismImpl(node);
      }
      else if (type == DESIGNATOR) {
        return new VHDLDesignatorImpl(node);
      }
      else if (type == DESIGN_FILE) {
        return new VHDLDesignFileImpl(node);
      }
      else if (type == DESIGN_UNIT) {
        return new VHDLDesignUnitImpl(node);
      }
      else if (type == DIRECTION) {
        return new VHDLDirectionImpl(node);
      }
      else if (type == DISCONNECTION_SPECIFICATION) {
        return new VHDLDisconnectionSpecificationImpl(node);
      }
      else if (type == DISCRETE_RANGE) {
        return new VHDLDiscreteRangeImpl(node);
      }
      else if (type == ELEMENT_ASSOCIATION) {
        return new VHDLElementAssociationImpl(node);
      }
      else if (type == ELEMENT_DECLARATION) {
        return new VHDLElementDeclarationImpl(node);
      }
      else if (type == ELEMENT_SUBTYPE_DEFINITION) {
        return new VHDLElementSubtypeDefinitionImpl(node);
      }
      else if (type == ENTITY_ASPECT) {
        return new VHDLEntityAspectImpl(node);
      }
      else if (type == ENTITY_CLASS) {
        return new VHDLEntityClassImpl(node);
      }
      else if (type == ENTITY_CLASS_ENTRY) {
        return new VHDLEntityClassEntryImpl(node);
      }
      else if (type == ENTITY_CLASS_ENTRY_LIST) {
        return new VHDLEntityClassEntryListImpl(node);
      }
      else if (type == ENTITY_DECLARATION) {
        return new VHDLEntityDeclarationImpl(node);
      }
      else if (type == ENTITY_DECLARATIVE_ITEM) {
        return new VHDLEntityDeclarativeItemImpl(node);
      }
      else if (type == ENTITY_DECLARATIVE_PART) {
        return new VHDLEntityDeclarativePartImpl(node);
      }
      else if (type == ENTITY_DESIGNATOR) {
        return new VHDLEntityDesignatorImpl(node);
      }
      else if (type == ENTITY_HEADER) {
        return new VHDLEntityHeaderImpl(node);
      }
      else if (type == ENTITY_NAME_LIST) {
        return new VHDLEntityNameListImpl(node);
      }
      else if (type == ENTITY_SPECIFICATION) {
        return new VHDLEntitySpecificationImpl(node);
      }
      else if (type == ENTITY_STATEMENT) {
        return new VHDLEntityStatementImpl(node);
      }
      else if (type == ENTITY_STATEMENT_PART) {
        return new VHDLEntityStatementPartImpl(node);
      }
      else if (type == ENTITY_TAG) {
        return new VHDLEntityTagImpl(node);
      }
      else if (type == ENUMERATION_LITERAL) {
        return new VHDLEnumerationLiteralImpl(node);
      }
      else if (type == ENUMERATION_TYPE_DEFINITION) {
        return new VHDLEnumerationTypeDefinitionImpl(node);
      }
      else if (type == EXIT_STATEMENT) {
        return new VHDLExitStatementImpl(node);
      }
      else if (type == EXPONENT) {
        return new VHDLExponentImpl(node);
      }
      else if (type == EXPRESSION) {
        return new VHDLExpressionImpl(node);
      }
      else if (type == EXTENDED_DIGIT) {
        return new VHDLExtendedDigitImpl(node);
      }
      else if (type == EXTENDED_IDENTIFIER) {
        return new VHDLExtendedIdentifierImpl(node);
      }
      else if (type == FACTOR) {
        return new VHDLFactorImpl(node);
      }
      else if (type == FILE_DECLARATION) {
        return new VHDLFileDeclarationImpl(node);
      }
      else if (type == FILE_LOGICAL_NAME) {
        return new VHDLFileLogicalNameImpl(node);
      }
      else if (type == FILE_OPEN_INFORMATION) {
        return new VHDLFileOpenInformationImpl(node);
      }
      else if (type == FILE_TYPE_DEFINITION) {
        return new VHDLFileTypeDefinitionImpl(node);
      }
      else if (type == FLOATING_TYPE_DEFINITION) {
        return new VHDLFloatingTypeDefinitionImpl(node);
      }
      else if (type == FORMAL_DESIGNATOR) {
        return new VHDLFormalDesignatorImpl(node);
      }
      else if (type == FORMAL_PARAMETER_LIST) {
        return new VHDLFormalParameterListImpl(node);
      }
      else if (type == FORMAL_PART) {
        return new VHDLFormalPartImpl(node);
      }
      else if (type == FULL_TYPE_DECLARATION) {
        return new VHDLFullTypeDeclarationImpl(node);
      }
      else if (type == FUNCTION_CALL) {
        return new VHDLFunctionCallImpl(node);
      }
      else if (type == GENERATE_STATEMENT) {
        return new VHDLGenerateStatementImpl(node);
      }
      else if (type == GENERATION_SCHEME) {
        return new VHDLGenerationSchemeImpl(node);
      }
      else if (type == GENERIC_CLAUSE) {
        return new VHDLGenericClauseImpl(node);
      }
      else if (type == GENERIC_LIST) {
        return new VHDLGenericListImpl(node);
      }
      else if (type == GENERIC_MAP_ASPECT) {
        return new VHDLGenericMapAspectImpl(node);
      }
      else if (type == GRAPHIC_CHARACTER) {
        return new VHDLGraphicCharacterImpl(node);
      }
      else if (type == GROUP_CONSTITUENT) {
        return new VHDLGroupConstituentImpl(node);
      }
      else if (type == GROUP_CONSTITUENT_LIST) {
        return new VHDLGroupConstituentListImpl(node);
      }
      else if (type == GROUP_DECLARATION) {
        return new VHDLGroupDeclarationImpl(node);
      }
      else if (type == GROUP_TEMPLATE_DECLARATION) {
        return new VHDLGroupTemplateDeclarationImpl(node);
      }
      else if (type == GUARDED_SIGNAL_SPECIFICATION) {
        return new VHDLGuardedSignalSpecificationImpl(node);
      }
      else if (type == IDENTIFIER) {
        return new VHDLIdentifierImpl(node);
      }
      else if (type == IDENTIFIER_LIST) {
        return new VHDLIdentifierListImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new VHDLIfStatementImpl(node);
      }
      else if (type == INCOMPLETE_TYPE_DECLARATION) {
        return new VHDLIncompleteTypeDeclarationImpl(node);
      }
      else if (type == INDEXED_NAME) {
        return new VHDLIndexedNameImpl(node);
      }
      else if (type == INDEX_CONSTRAINT) {
        return new VHDLIndexConstraintImpl(node);
      }
      else if (type == INDEX_SPECIFICATION) {
        return new VHDLIndexSpecificationImpl(node);
      }
      else if (type == INDEX_SUBTYPE_DEFINITION) {
        return new VHDLIndexSubtypeDefinitionImpl(node);
      }
      else if (type == INSTANTIATED_UNIT) {
        return new VHDLInstantiatedUnitImpl(node);
      }
      else if (type == INSTANTIATION_LIST) {
        return new VHDLInstantiationListImpl(node);
      }
      else if (type == INTEGER) {
        return new VHDLIntegerImpl(node);
      }
      else if (type == INTEGER_TYPE_DEFINITION) {
        return new VHDLIntegerTypeDefinitionImpl(node);
      }
      else if (type == INTERFACE_CONSTANT_DECLARATION) {
        return new VHDLInterfaceConstantDeclarationImpl(node);
      }
      else if (type == INTERFACE_DECLARATION) {
        return new VHDLInterfaceDeclarationImpl(node);
      }
      else if (type == INTERFACE_ELEMENT) {
        return new VHDLInterfaceElementImpl(node);
      }
      else if (type == INTERFACE_FILE_DECLARATION) {
        return new VHDLInterfaceFileDeclarationImpl(node);
      }
      else if (type == INTERFACE_LIST) {
        return new VHDLInterfaceListImpl(node);
      }
      else if (type == INTERFACE_SIGNAL_DECLARATION) {
        return new VHDLInterfaceSignalDeclarationImpl(node);
      }
      else if (type == INTERFACE_VARIABLE_DECLARATION) {
        return new VHDLInterfaceVariableDeclarationImpl(node);
      }
      else if (type == ITERATION_SCHEME) {
        return new VHDLIterationSchemeImpl(node);
      }
      else if (type == LABEL) {
        return new VHDLLabelImpl(node);
      }
      else if (type == LETTER) {
        return new VHDLLetterImpl(node);
      }
      else if (type == LETTER_OR_DIGIT) {
        return new VHDLLetterOrDigitImpl(node);
      }
      else if (type == LIBRARY_CLAUSE) {
        return new VHDLLibraryClauseImpl(node);
      }
      else if (type == LIBRARY_UNIT) {
        return new VHDLLibraryUnitImpl(node);
      }
      else if (type == LITERAL) {
        return new VHDLLiteralImpl(node);
      }
      else if (type == LOGICAL_NAME) {
        return new VHDLLogicalNameImpl(node);
      }
      else if (type == LOGICAL_NAME_LIST) {
        return new VHDLLogicalNameListImpl(node);
      }
      else if (type == LOGICAL_OPERATOR) {
        return new VHDLLogicalOperatorImpl(node);
      }
      else if (type == LOOP_STATEMENT) {
        return new VHDLLoopStatementImpl(node);
      }
      else if (type == MISCELLANEOUS_OPERATOR) {
        return new VHDLMiscellaneousOperatorImpl(node);
      }
      else if (type == MODE) {
        return new VHDLModeImpl(node);
      }
      else if (type == MULTIPLYING_OPERATOR) {
        return new VHDLMultiplyingOperatorImpl(node);
      }
      else if (type == NAME) {
        return new VHDLNameImpl(node);
      }
      else if (type == NEXT_STATEMENT) {
        return new VHDLNextStatementImpl(node);
      }
      else if (type == NULL_STATEMENT) {
        return new VHDLNullStatementImpl(node);
      }
      else if (type == NUMERIC_LITERAL) {
        return new VHDLNumericLiteralImpl(node);
      }
      else if (type == OBJECT_DECLARATION) {
        return new VHDLObjectDeclarationImpl(node);
      }
      else if (type == OPERATOR_SYMBOL) {
        return new VHDLOperatorSymbolImpl(node);
      }
      else if (type == OPTIONS) {
        return new VHDLOptionsImpl(node);
      }
      else if (type == PACKAGE_BODY) {
        return new VHDLPackageBodyImpl(node);
      }
      else if (type == PACKAGE_BODY_DECLARATIVE_ITEM) {
        return new VHDLPackageBodyDeclarativeItemImpl(node);
      }
      else if (type == PACKAGE_BODY_DECLARATIVE_PART) {
        return new VHDLPackageBodyDeclarativePartImpl(node);
      }
      else if (type == PACKAGE_DECLARATION) {
        return new VHDLPackageDeclarationImpl(node);
      }
      else if (type == PACKAGE_DECLARATIVE_ITEM) {
        return new VHDLPackageDeclarativeItemImpl(node);
      }
      else if (type == PACKAGE_DECLARATIVE_PART) {
        return new VHDLPackageDeclarativePartImpl(node);
      }
      else if (type == PARAMETER_SPECIFICATION) {
        return new VHDLParameterSpecificationImpl(node);
      }
      else if (type == PHYSICAL_LITERAL) {
        return new VHDLPhysicalLiteralImpl(node);
      }
      else if (type == PHYSICAL_TYPE_DEFINITION) {
        return new VHDLPhysicalTypeDefinitionImpl(node);
      }
      else if (type == PORT_CLAUSE) {
        return new VHDLPortClauseImpl(node);
      }
      else if (type == PORT_LIST) {
        return new VHDLPortListImpl(node);
      }
      else if (type == PORT_MAP_ASPECT) {
        return new VHDLPortMapAspectImpl(node);
      }
      else if (type == PREFIX) {
        return new VHDLPrefixImpl(node);
      }
      else if (type == PRIMARY) {
        return new VHDLPrimaryImpl(node);
      }
      else if (type == PRIMARY_UNIT) {
        return new VHDLPrimaryUnitImpl(node);
      }
      else if (type == PROCEDURE_CALL) {
        return new VHDLProcedureCallImpl(node);
      }
      else if (type == PROCEDURE_CALL_STATEMENT) {
        return new VHDLProcedureCallStatementImpl(node);
      }
      else if (type == PROCESS_DECLARATIVE_ITEM) {
        return new VHDLProcessDeclarativeItemImpl(node);
      }
      else if (type == PROCESS_DECLARATIVE_PART) {
        return new VHDLProcessDeclarativePartImpl(node);
      }
      else if (type == PROCESS_STATEMENT) {
        return new VHDLProcessStatementImpl(node);
      }
      else if (type == PROCESS_STATEMENT_PART) {
        return new VHDLProcessStatementPartImpl(node);
      }
      else if (type == QUALIFIED_EXPRESSION) {
        return new VHDLQualifiedExpressionImpl(node);
      }
      else if (type == RANGE) {
        return new VHDLRangeImpl(node);
      }
      else if (type == RANGE_CONSTRAINT) {
        return new VHDLRangeConstraintImpl(node);
      }
      else if (type == RECORD_TYPE_DEFINITION) {
        return new VHDLRecordTypeDefinitionImpl(node);
      }
      else if (type == RELATION) {
        return new VHDLRelationImpl(node);
      }
      else if (type == RELATIONAL_OPERATOR) {
        return new VHDLRelationalOperatorImpl(node);
      }
      else if (type == REPORT_STATEMENT) {
        return new VHDLReportStatementImpl(node);
      }
      else if (type == RETURN_STATEMENT) {
        return new VHDLReturnStatementImpl(node);
      }
      else if (type == SCALAR_TYPE_DEFINITION) {
        return new VHDLScalarTypeDefinitionImpl(node);
      }
      else if (type == SECONDARY_UNIT) {
        return new VHDLSecondaryUnitImpl(node);
      }
      else if (type == SECONDARY_UNIT_DECLARATION) {
        return new VHDLSecondaryUnitDeclarationImpl(node);
      }
      else if (type == SELECTED_NAME) {
        return new VHDLSelectedNameImpl(node);
      }
      else if (type == SELECTED_SIGNAL_ASSIGNMENT) {
        return new VHDLSelectedSignalAssignmentImpl(node);
      }
      else if (type == SELECTED_WAVEFORMS) {
        return new VHDLSelectedWaveformsImpl(node);
      }
      else if (type == SENSITIVITY_CLAUSE) {
        return new VHDLSensitivityClauseImpl(node);
      }
      else if (type == SENSITIVITY_LIST) {
        return new VHDLSensitivityListImpl(node);
      }
      else if (type == SEQUENCE_OF_STATEMENTS) {
        return new VHDLSequenceOfStatementsImpl(node);
      }
      else if (type == SEQUENTIAL_STATEMENT) {
        return new VHDLSequentialStatementImpl(node);
      }
      else if (type == SHIFT_EXPRESSION) {
        return new VHDLShiftExpressionImpl(node);
      }
      else if (type == SHIFT_OPERATOR) {
        return new VHDLShiftOperatorImpl(node);
      }
      else if (type == SIGN) {
        return new VHDLSignImpl(node);
      }
      else if (type == SIGNAL_ASSIGNMENT_STATEMENT) {
        return new VHDLSignalAssignmentStatementImpl(node);
      }
      else if (type == SIGNAL_DECLARATION) {
        return new VHDLSignalDeclarationImpl(node);
      }
      else if (type == SIGNAL_KIND) {
        return new VHDLSignalKindImpl(node);
      }
      else if (type == SIGNAL_LIST) {
        return new VHDLSignalListImpl(node);
      }
      else if (type == SIGNATURE) {
        return new VHDLSignatureImpl(node);
      }
      else if (type == SIMPLE_EXPRESSION) {
        return new VHDLSimpleExpressionImpl(node);
      }
      else if (type == SIMPLE_NAME) {
        return new VHDLSimpleNameImpl(node);
      }
      else if (type == SLICE_NAME) {
        return new VHDLSliceNameImpl(node);
      }
      else if (type == STRING_LITERAL) {
        return new VHDLStringLiteralImpl(node);
      }
      else if (type == SUBPROGRAM_BODY) {
        return new VHDLSubprogramBodyImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATION) {
        return new VHDLSubprogramDeclarationImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATIVE_ITEM) {
        return new VHDLSubprogramDeclarativeItemImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATIVE_PART) {
        return new VHDLSubprogramDeclarativePartImpl(node);
      }
      else if (type == SUBPROGRAM_KIND) {
        return new VHDLSubprogramKindImpl(node);
      }
      else if (type == SUBPROGRAM_SPECIFICATION) {
        return new VHDLSubprogramSpecificationImpl(node);
      }
      else if (type == SUBPROGRAM_STATEMENT_PART) {
        return new VHDLSubprogramStatementPartImpl(node);
      }
      else if (type == SUBTYPE_DECLARATION) {
        return new VHDLSubtypeDeclarationImpl(node);
      }
      else if (type == SUBTYPE_INDICATION) {
        return new VHDLSubtypeIndicationImpl(node);
      }
      else if (type == SUFFIX) {
        return new VHDLSuffixImpl(node);
      }
      else if (type == TARGET) {
        return new VHDLTargetImpl(node);
      }
      else if (type == TERM) {
        return new VHDLTermImpl(node);
      }
      else if (type == TIMEOUT_CLAUSE) {
        return new VHDLTimeoutClauseImpl(node);
      }
      else if (type == TYPE_CONVERSION) {
        return new VHDLTypeConversionImpl(node);
      }
      else if (type == TYPE_DECLARATION) {
        return new VHDLTypeDeclarationImpl(node);
      }
      else if (type == TYPE_DEFINITION) {
        return new VHDLTypeDefinitionImpl(node);
      }
      else if (type == TYPE_MARK) {
        return new VHDLTypeMarkImpl(node);
      }
      else if (type == UNCONSTRAINED_ARRAY_DEFINITION) {
        return new VHDLUnconstrainedArrayDefinitionImpl(node);
      }
      else if (type == USE_CLAUSE) {
        return new VHDLUseClauseImpl(node);
      }
      else if (type == VARIABLE_ASSIGNMENT_STATEMENT) {
        return new VHDLVariableAssignmentStatementImpl(node);
      }
      else if (type == VARIABLE_DECLARATION) {
        return new VHDLVariableDeclarationImpl(node);
      }
      else if (type == WAIT_STATEMENT) {
        return new VHDLWaitStatementImpl(node);
      }
      else if (type == WAVEFORM) {
        return new VHDLWaveformImpl(node);
      }
      else if (type == WAVEFORM_ELEMENT) {
        return new VHDLWaveformElementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
